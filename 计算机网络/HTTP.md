# HTTP 

超文本传输协议 (HTTP) 是 Internet 上最普遍和最广泛采用的应用协议之一。HTTP的发展与万维网的发展息息相关。

## HTTP 0.9

万维网之父Tim Berners-Lee的人想让他的万维网提案被采用，由此设计了HTTP协议。

- 客户端请求是单个 ASCII 字符串。
- 客户端请求由回车 (CRLF) 终止。
- 服务器响应是一个 ASCII 字符流。
- 服务器响应是一种超文本标记语言 (HTML)。
- 文件传输完成后连接终止。

## HTTP 1.0

基于 Tim Berners-Lee 的初始浏览器原型，国家超级计算应用中心 (NCSA) 的一个团队决定实现他们自己的版本。于是，第一个流行的浏览器诞生了：NCSA Mosaic。在同年，瑞士日内瓦组织了第一次万维网会议，从而促成了万维网联盟 (W3C) 的创建。CompuServe、AOL 和 Prodigy 开始在 1994 年至 1995 年的同一时间段内向公众提供拨号上网服务。由此，互联网热潮已经到来。

新兴 Web 及其在公共 Web 上的用例越来越多的所需功能很快暴露了 HTTP 0.9 的许多基本限制：我们需要一个协议，它不仅可以服务于超文本文档，还可以提供和协商关于请求和响应的更丰富的元数据。web开发人员社区开始进行大量实验性的HTTP实现。

由此，HTTP工作组在1996年发布了RFC1945文件，其中记录了HTTP/1.0 实现的常用规范。但这并不是正式的规范或Internet标准！

### http URL

http_URL = "http:"  "//"  host [ ":" port ] [ abs_path ] 

注：HTTP/1.0并不能在url后拼接参数。

### 请求

考虑局限性和HTTP/0.9的 向后兼容性。请求分为简单请求和复杂请求，简单请求即 HTTP0.9格式。如果HTTP/1.0服务器收到简单请求，它必须回应一个HTTP/0.9格式的简单请求。HTTP/1.0的客户端又能力接收完整回应，但不能产生简单请求。

复杂请求规定了3种方法：get，post，head。

请求头：Authorization，From（传入用户的邮箱地址），if-Modified-Since，Referer，User-Agent（用户信息）。

![img](https://daytime-1303889004.cos.ap-nanjing.myqcloud.com/007.png)

### 响应

响应分为简单响应和复杂响应。如果客户端发送HTTP/1.0完整请求后，接收到的回应不是以状态行开头的，客户端将其视为简单回应，并对其进行解析。

状态行依次由协议版本、数字形式的状态代码组成。

响应头：Location（由请求URI指定的资源的位置）、Server(服务器软件信息)、WWW-Authenticate

实体由实体头和实体主体组成。

实体头：Allow（允许的访问方法）、Content-Encoding、Content-Length、Content-type、Expires、Last-Modified

![](https://daytime-1303889004.cos.ap-nanjing.myqcloud.com/008.png)

## HTTP/1.1

在HTTP/1.0发布6个月后，第一个官方HTTP/1.1标准发布。然后在2年半后的1999年，该标准中包含了许多改进和更新，并作为 RFC 2616 发布。

### http URL

`http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ]]`

HTTP协议不对URI的长度作事先的限制，服务器必须能够处理任何他们提供资源的URI，并且应该能够处理无限长度的URIs，这种无效长度的URL可能会在客户端以基于GET方式的请求时产生。如果服务器不能处理太长的URI的时候，服务器应该返回414状态码。

### 丢失的字符集

解析Content-Type头时，当发现没有字符集参数（Content-Type: text/plain; charset=UTF-8，此时charset=UTF-8就是字符集参数）可用时，这意味着接收者必须猜测实体主体的字符集到底是什么。如果发送者希望避免这种情况，他应该在Content-Type头域里包含一个字符集参数。

### 分块传输

通常情况下，HTTP的响应消息体 message body 是作为整包发送到客户端的，用头Content-Length 来表示消息体的长度， 这个长度对客户端非常重要，因为对于持久连接TCP并不会在请求完立马结束，而是可以发送多次请求/响应，客户端需要知道哪个位置才是响应消息的结束，以及后续响应的开始，因此Content-Length显得尤为重要，服务端必须精确地告诉客户端 message body 的长度是多少， 如果Content-Length 比实际返回的长度短，那么就会造成内容截断，如果比实体内容长，客户端就一直处于pendding状态，直到所有的 message body 都返回了请求才结束。

Web2.0的出现使得网页变得丰富多彩，内容也比早期的网页复杂很多，这样就会遇到一个问题，对于一个复杂的页面来说，如果是等到消息体完全创建好之后再计算出Content-Length返回给客户端的话，在客户端那边会有一个漫长的等待过程，而对于用户来说，一个页面的所能容忍的等待时间不超过3秒，因此如何让响应内容尽可能早的让用户看到是HTTP协议要考虑的问题。

**分块传输编码 **就是这样一种解决方案：它把数据分解成一系列数据块，并以多个块发送给客户端，服务器发送数据时不再需要预先告诉客户端发送内容的总大小，只需在响应头里面添加`Transfer-Encoding: chunked`，以此来告诉浏览器我使用的是分块传输编码，这样就不需要 Content-Length 了，这就是分块传输编码 Transfer-Encoding 的作用。

### 分块传输编码带来的好处：

- HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。
- 分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。
- HTTP服务器有时使用压缩（gzip）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。

### 常用头域（适用请求也适用响应）

Connection 

Pragma 

Transfer-Encoding

Upgrade ：允许客户端指定它所支持的附加通信协议，并且可能会使用如果服务器觉得可以进行协议切换。

Via 

Date：表明产生消息的日期和时间

Cache-Control：指定必须在请求/响应链上的被所有缓存机制遵守指令。

### 请求方法

get：可以通过在请求头设置 If-Modified-Since,，If-Unmodified-Since，If-Match，If-None-Match或者 If-Range头域，GET的语义将变成“条件 GET”。一个条件GET方法会请求满足条件头域的实体。条件GET方法的目的是为了减少不必要的网络使用。如果请求方法包含一个Range头域，那么GET方法就变成“部分Get”（partial GET）方法。一个部分GET会请求实体的一部分，目的是为了减少不必要的网络使用。

head：HEAD方法和GET方法一致，除了服务器不能在响应里返回消息主体。

post：略。

put：PUT方法请求服务器去把请求里的实体存储在请求URI标识下。如果请求URI指定的的资源已经在源服务器上存在，那么此请求里的实体应该被当作是源服务器关于此URI所指定资源实体的最新修改版本。如果请求URI指定的资源不存在，并且此URI被用户代理定义为一个新资源，那么源服务器就应该根据请求里的实体创建一个此URI所标识下的资源。

注：POST方法和PUT方法请求最根本的区别是请求URI（Request-URI）的含义不同。POST请求里的URI指示一个能处理请求实体的资源（此资源可能是一段程序，如jsp里的servlet）。此资源可能是一个数据接收过程，一个网关，或者一个单独接收注释的实体。对比而言，PUT方法请求里的URI标识请求里封装的实体一一用户代理知道URI意指什么，并且服务器不能把此请求应用于其它资源。

delete：DELETE方法请求源服务器删除请求URI指定的资源。此方法可能会在源服务器上被人为的干涉（或通过其他方法）。客户端不能保证此操作能被执行，即使源服务器返回成功状态码。然而，服务器不应该指明成功除非它打算删除资源或把此资源移到一个不可访问的位置。

trace：TRACE方法被用于激发一个远程的，应用层的请求消息回路（TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路，）。最后的接收者也许是源服务器，也许是接收到包含Max-Forwards头域值为0请求的代理或网关。TRACE请求不能包含一个实体。TRACE方法允许客户端去了解数据被请求链的另一端接收的情况，并且利用那些数据信息去测试或诊断。

connect：HTTP1.1协议规范保留了CONNECT方法，此方法是为了能用于能动态切换到隧道的代理（如 SSL tunneling.）。

options：OPTIONS方法表明请求想得到请求/响应链上关于此请求里的URI指定资源的通信选项信息。此方法允许客户端去判定请求资源的选项和/或需求，或者服务器的能力，而不需要利用一个资源动作方法。此方法的响应是不能缓存的。

### 请求头部

Accept：用于指定哪些媒体类型的响应对请求端是可接受的。

Accept-Charset：指名哪些字符集的响应对请求端是可接受的。

Accept-Encoding：限定服务器返回给客户端可以接受的内容编码。

Accept-Language：限定服务器返回给客户端喜爱的自然语言。

Authorization ：用户代理往往希望通过服务器给自己授权。

Expect：用于指明客户端需要的特定服务器行为。

If-Match：如果一个客户端已经从一个资源获得一个或多个实体（entity），那么它可以通过在If-Match头域里包含相应的实体标签（entity tag）来验证实体是否就是服务器当前实体。

If-Modified-Since：如果请求变量（variant）自从此头域里指定的时间之后没有改变，那么服务器不应该返回实体；而是应该以304（没有改变）状态码进行响应，同时返回的消息不需要消息主体（message-body）。

If-None-Match

If-Range 

If-Unmodified-Since

### 响应头部

Accept-Range：响应头域允许服务器向客户指明服务器对范围请求的接受度。

Age：表示发送者对响应产生（或重验证）时刻后经过的时间的估计。

Allow：实体头域中被URI指定的资源所支持的方法。

Etag：请求对应变量（variant）的当前实体标签

### 实体头部

Content-Type：指明发给接收者的实体主体的媒体类型。

Expires：给出了在何时之后响应即被视为陈旧的。

Last-Modified：变量被源服务器所确信的最后修改的日期和时间。