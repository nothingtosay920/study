# 协议栈的内部结构 

​		协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。

​		下面一半是用 IP 协议控制网络包收发操作的部分。IP协议用来负责向通信对象发送数据包。IP 中还包括 ICMPA 协议和 ARPB 协议。 ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用 于根据 IP 地址查询相应的以太网 MAC 地址 C。

​		IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完 成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

​		协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。协议栈在执行操作时需要参阅这些控制信息。

## 创建套接字

​		应用程序调用 socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间来 D，这相当于为控制信息准备一个容器。但光 一个容器并没有什么用，还需要往里面存入控制信息。套接字刚刚创建时， 数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一 初始状态的控制信息。再将表示这个套接字的描述符告知应用程序。收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。

## 连接服务器

​		虽然套接字已经创建并且初始化好了，但是套接字并没存放任何数据，也不知道通信对象是谁。

​		应用程序调用connect组件，随后协议栈会将本地的套接字与服务器的套接字进行连接，在连接服务器的这个过程中，应用程序会把服务器的IP地址和端口号等信息告知协议栈中的TCP模块，这一交互过程包括下面几个步骤。首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部，头部中有服务端的套接字也就弄清楚了应该连接哪个套接字。服务器同样需要创建套接字，服务器一般在系统启动时就创建套接字并等待客户端连接。

​		当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送。IP 模块执行网络包发送操作后，网络包就会通过网络到 达服务器，然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块， 服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应 的信息，并将状态改为正在连接。上述操作完成后，服务器的 TCP 模块会返回响应。服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应。

​		然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功。若连接成功会向套接字写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕。

## 发送数据

​		控制流回到应用程序，进入数据发送阶段。

​		应用程序调用write将要发送的数据交给协议栈，协议栈收到数据后执行发送操作。

​		协议栈并不是一收到数据就马上发送出去，而是会将数据存放 在内部的发送缓冲区中，并等待应用程序的下一段数据。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不 同的应用程序在实现上有所不同。在这样的情况下， 如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效 率下降，因此需要在数据积累到一定量时再发送出去。至于要积累多少数 据才能发送，不同种类和版本的操作系统会有所不同。

​		要素1: 是每个网络包能容纳的数据长度，协议栈会根据一个 叫作 MTUA 的参数来进行判断。MTU 表示一个网络包的最大长度，在以太 网中一般是 1500 字节。而一个网络包中能包含最大数据长度叫做MSS，当从应用程序收到的数据长度超过或者接 近 MSS 时再发送出去，就可以避免发送大量小包的问题了。

​		要素2:  时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去。协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。

​		考虑到这两个要素是互相矛盾的，所以在进行发送操作时需要综合考虑这两个要素以达到平衡。TCP协议规定中并没有告诉我们怎样平衡，因此实际判断由协议栈的开发者来决定，也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。

### 发送时对较大数据拆分

​		HTTP请求消息一般不会很长，一个网络包就能装下，但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量。这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当 然不需要继续等待后面的数据了。发送缓冲区中的数据会被以 MSS 长度为 单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。

​		根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就 在每一块数据前面加上 TCP 头部，并根据套接字中记录的控制信息标记发送 方和接收方的端口号，然后交给 IP 模块来执行发送数据的操作。

![拆分过程](https://daytime-1303889004.cos.ap-nanjing.myqcloud.com/005.png)

## 接收消息

​		和发送数据一样，接收数据也需要 将数据暂存到接收缓冲区中。首先，协议栈尝试从 接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这 时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递 给应用程序的工作暂时挂起 B，等服务器返回的响应消息到达之后再继续执行接收操作。

​		首先，协议栈会检查收到的数据块和 TCP 头 部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。然后， 协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的 数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。 将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。（待完善）