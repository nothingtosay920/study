# 解析HTML

HTML 解析过程的输入由 Unicode 字符流组成，该流通过 Tokenizer阶段，然后是构建树阶段。输出是一个`Document` 对象。

## 输入流

在网络请求获得的字节流通过字节流解码器解码成Unicode字符，在这个过程需要确定字符编码。

在某些情况下，在解析文档之前明确地确定编码可能是不切实际的。在开始解析文档之前，实现允许对任何可用的字节应用简化的解析算法。然后，使用从预解析和其他带外元数据派生的试探性编码启动真正的解析器。如果在加载文档时，用户代理发现与此信息冲突的编码声明，那么可以重新调用解析器，以使用实际编码对文档进行解析。

浏览器使用以下算法(编码嗅探算法)来确定在第一次对文档进行解码时使用的字符编码。该算法将浏览器可用的任何带外元数据(例如文档的Content-Type元数据)和到目前为止可用的所有字节作为输入，并返回编码和置信值。这种信心要么是不确定的，要么是肯定的，要么是不相关的。在解析过程中使用所使用的编码，以及该编码中的可信度是试探性的还是确定的，以确定是否要更改编码。如果不需要编码，例如，因为解析器操作的是Unicode字符流，根本不需要使用编码，那么置信度就无关紧要了。

## 解析过程

HTML与CSS、JS的解析不同，HTML的语言语法并不是上下文无关文法，因此不能使用常规的解析技术进行解析。HTML也与XML不同，HTML有很好的容错性即包容性，HTML能够包容我们的错误，简化网络开发，因此XML解析器也不适合HTML。‘

HTML采用了DTD的格式，解析正是以招这种格式来解析。

HTML解析算法分为2个阶段：标记化和树构建。

## 标记化算法

该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。

## 树构建算法

在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。

## 解析结束后的操作

在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。